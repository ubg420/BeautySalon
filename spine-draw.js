"use strict";class SpineBatch{constructor(){this._initialized=!1,this._skeletonInstances={},this._rendered=!1,this._tickCount=-1,this._renderRate=1,this._spineGLCache=null,this._spineGLCacheStored=!1,this._debugVariables={animationReduce:"disable",spineGLCache:"disable",animationDisable:"disable",renderDisable:"disable"}}get rendered(){return this._rendered}get initialized(){return this._initialized}get tickCount(){return this._tickCount}set tickCount(e){this._tickCount=e}get renderRate(){return this._renderRate}set renderRate(e){this._renderRate=e}get debugVariables(){return this._debugVariables}init(e,t){const s=globalThis.spine;if(this._initialized)return;this.runtime=t,this.canvas=e,this.gl=this.runtime.GetWebGLRenderer()._gl;const n=this.gl;let i=0;this.isWebGL2=!1;let r=n.getParameter(n.VERSION);if(-1!==r.indexOf("WebGL")?(i=parseFloat(/^WebGL\ ([0-9])/.exec(r)[1]),this.isWebGL2=i>=2):-1!==r.indexOf("OpenGL ES")&&(i=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(r)[1]),this.isWebGL2=i>=3),this.isWebGL2)this.myVAO=n.createVertexArray();else{let e=n.getExtension("OES_vertex_array_object");if(!e)return void console.error("Spine plugin error: webGL1 with no OES_vertex_array_object support");this.myVAO=e.createVertexArrayOES()}this.mvp=new s.Matrix4,this.shader=s.Shader.newTwoColoredTextured(n),this.batcher=new s.PolygonBatcher(n),this.renderer=new s.SkeletonRenderer(n),this.shapes=new s.ShapeRenderer(n),this._initialized=!0,this._spineGLCache=new globalThis.SpineGLCache(this.isWebGL2,n)}addInstance(e,t,s){this._skeletonInstances[s]={},this._skeletonInstances[s].skeletonInfo=e,this._skeletonInstances[s].initialized=!1,this._skeletonInstances[s].skeletonScale=t,this._skeletonInstances[s].onScreen=!0,this._skeletonInstances[s].tracksComplete=!1,this._skeletonInstances[s].renderOnce=!0}removeInstance(e){this._skeletonInstances[e]&&delete this._skeletonInstances[e]}setInstanceInitialized(e){this._skeletonInstances[e]&&(this._skeletonInstances[e].initialized=!0)}setInstanceFB(e,t){this._skeletonInstances[t]&&(this._skeletonInstances[t].spineFB=e)}setInstancePalette(e,t){this._skeletonInstances[t]&&(this._skeletonInstances[t].palette=e)}setInstanceOnScreen(e,t){this._skeletonInstances[t]&&(this._skeletonInstances[t].onScreen=e)}setInstanceTracksComplete(e,t){this._skeletonInstances[t]&&(!this._skeletonInstances[t].tracksComplete&&e&&(this._skeletonInstances[t].renderOnce=!0),this._skeletonInstances[t].tracksComplete=e)}setInstanceRenderOnce(e,t){this._skeletonInstances[t]&&(this._skeletonInstances[t].renderOnce=e)}setInstanceAnimationStop(e,t){this._skeletonInstances[t]&&(this._skeletonInstances[t].animationStop=e)}resize(e,t){var s=e.offset.x+e.size.x/2,n=e.offset.y+e.size.y/2,i=e.size.x/e.size.x,r=e.size.y/e.size.y,a=Math.max(i,r)*(1/t);a<1&&(a=1);var l=e.size.x*a,o=e.size.y*a;this.mvp.ortho2d(s-l/2,n-o/2,l,o)}drawBatch(){if("enable"===this.debugVariables.renderDisable)return void(this._rendered=!0);const e=globalThis.spine,t=this.gl,s=this._skeletonInstances;if(this._spineGLCacheStored&&"enable"===this._debugVariables.spineGLCache||(this._spineGLCache.store(),this._spineGLCacheStored=!0),this.isWebGL2)t.bindVertexArray(this.myVAO);else{t.getExtension("OES_vertex_array_object").bindVertexArrayOES(this.myVAO)}let n=this.runtime.GetTickCount(),i=0;for(const r in s){const a=s[r],l=a.palette,o=a.skeletonInfo.skeleton.sequenceActive,h=a.skeletonInfo.sequenceAutoplay,c=a.skeletonInfo.sequenceFPS;if(a.initialized&&n%this._renderRate==i%this._renderRate&&(o||a.renderOnce||!a.tracksComplete&&a.onScreen&&!a.animationStop)){0;const s=a.skeletonInfo.bounds,n=a.skeletonInfo.premultipliedAlpha;t.bindFramebuffer(t.FRAMEBUFFER,a.spineFB),t.viewport(0,0,s.size.x,s.size.y),t.enable(t.BLEND),t.blendFunc(t.ONE,t.ONE_MINUS_SRC_ALPHA),t.disable(t.SCISSOR_TEST),t.bindTexture(t.TEXTURE_2D,null),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,l.paletteTexture),t.activeTexture(t.TEXTURE0),this.shader.bind(),this.resize(s,a.skeletonScale),this.shader.setUniform4x4f(e.Shader.MVP_MATRIX,this.mvp.values),this.batcher.begin(this.shader),this.renderer.vertexEffect=null,t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),this.renderer.premultipliedAlpha=n,this.renderer.draw(this.batcher,a.skeletonInfo.skeleton,-1,-1,h,c),this.batcher.end(),this.shader.unbind()}a.initialized&&l.uploadNeeded&&(l.uploadNeeded=!1,l.upload(t.TEXTURE1,t)),i++}this._rendered=!0,this._spineGLCache.restore()}getRValue(e){const t=16384;if(e>=0)return(255&e)/255;{let s=Math.floor(-e/274877906944);return s>8191&&(s-=t),s/1024}}getGValue(e){const t=16384;if(e>=0)return((65280&e)>>8)/255;{let s=Math.floor(-e%274877906944/16777216);return s>8191&&(s-=t),s/1024}}getBValue(e){if(e>=0)return((16711680&e)>>16)/255;{let t=Math.floor(-e%16777216/1024);return t>8191&&(t-=16384),t/1024}}getAValue(e){if(0===e&&1/e<0)return 0;if(e>=0)return 1;return Math.floor(-e%1024)/1023}}globalThis.spineBatcher||(console.info("[Spine] SpineBatcher init, 2.8.4, Spine 4.1.x compatible"),globalThis.spineBatcher=new SpineBatch);